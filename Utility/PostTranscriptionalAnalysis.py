#!/usr/bin/python
# encoding: utf-8
# author: Charles Joly Beauparlant
# 2013-06-01

"""

Usage:

PostTranscriptionalAnalysis.py <file_list.txt> <file_pairs.txt> <mature_sequences.txt> <mode> <file_blast> <file_collapsed>
	file_list.txt:		List of file generated by the analysis of hairpins and converted to plain text.
	file_pairs.txt:		List of every combination of mature/pre-mature sequence (two column file, on pair per line).
	mature_sequences.txt:	The DNA sequence of each mature miRNA in fasta.
	mode: stat or count. Detailled stats for each miRNA seq or count by position, respectively.

"""

# Classes definitions
class MatureAllocator:
	def __init__(self, file_pairs):
		self.reset()
		self._load_file(file_pairs)

	def reset(self):
		self.m_pair_list = {}

	def get_mature_sequences(self, miRNA_name):
		if miRNA_name in self.m_pair_list:
			return self.m_pair_list[miRNA_name]
		else:
			return ""

	def _load_file(self, file_pairs):
		for line in open(file_pairs):
			tokens = line.split()
			genomic = tokens[0]
			mature = tokens[1]
			if genomic not in self.m_pair_list:
				self.m_pair_list[genomic] = []
			self.m_pair_list[genomic].append(mature)

# Genomic Sequence:	GGGUGAGGUAGUAGGUUGUAUAGUUUGGGGCUCUGCCCUGCUAUGGGAUAACUAUACAAU
# Mature Sequence:	    GAGGUAGUAGGUUGU
class MatureSequence:
	def __init__(self, mature_sequence, start_position, end_position):
		self.m_sequence = mature_sequence
		self.m_start_position = start_position
		self.m_end_position = end_position
		self.m_count = 0
#		self._calculate_positions(mature_sequence, genomic_sequence)

	def set_count(self, count):
		self.m_count = count
	
	def get_count(self):
		return self.m_count

	def get_sequence(self):
		return self.m_sequence

	def get_start(self):
		return self.m_start_position

	def get_end(self):
		return self.m_end_position
#
#	def _calculate_position(self, mature_sequence, genomic_sequence):
#		self.m_start_positions = genomic_sequence.index(mature_sequence)
#		self.m_end_position = self.m_start_position + len(mature_sequence)

class SequenceAnalyzer:
	def __init__(self, filename, mature_sequences, mature_allocator, mode, normalized, pairs):
		self.reset()
		self.m_mature_allocator = mature_allocator
		self.m_all_mature_sequences = mature_sequences
		self.m_mode = mode
		self._parse_file(filename, normalized, pairs)
		self._parse_results()

	def reset(self):
		self.m_name = ""
		self.m_genomic_sequence = ""
		self.m_current_mature_sequences = {}
		self.m_other_sequences = []

#
#    hsa-let-7a-3 [MI0000062](http://www.mirbase.org/cgi-bin/mirna_entry.pl?acc=MI0000062)
#    GGGUGAGGUAGUAGGUUGUAUAGUUUGGGGCUCUGCCCUGCUAUGGGAUAACUAUACAAU
#    ...((...((.(((.((.(((((...((()))..))))...).)))))))))..).))))
#
#        GAGGUAGUAGGUUGU 210386
#        GAGGUAGUAGGUUGUAUAGUU 88110
#        GAGGUAGUAGGUUGUAUAGU 39076
#        GAGGUAGUAGGUUGUAUAG 32771
	def _parse_file(self, filename, normalized, pairs):
#		for entry in normalized:
#			print "entry: " + entry + ": " + str(normalized[entry])
#		for entry in pairs:
#			print entry + ": " + pairs[entry]
		line_count = 0
		sequence_name = ""
		for line in open(filename):
			if line_count == 1: # This is the name of the miRNA
				sequence_name = line.split()[0]
				self.m_name = sequence_name
#				print "sequence_name: " + sequence_name
			if line_count == 2: # This is genomic sequence
				self.m_genomic_sequence = line.strip()
#				print "genomic: " + self.m_genomic_sequence
				# Add the infos about the mature sequences associated with this miRNA
				current_mature_sequences = self.m_mature_allocator.get_mature_sequences(sequence_name)
				for name in current_mature_sequences:
					if name in self.m_all_mature_sequences:
						sequence = self.m_all_mature_sequences[name]
	#					print "name: " + name
	#					print "sequence: " + sequence
						if sequence in self.m_genomic_sequence: # Note: it's possible that the mature sequence was not found in the reads # Actually, no, this was a bug. Keep this until solved
							start_position = self.m_genomic_sequence.index(sequence)
							end_position = start_position + len(sequence)
		#						print "start_position: " + str(start_position)
		#						print "end_position: " + str(end_position)
							self.m_current_mature_sequences[name] = MatureSequence(sequence, start_position, end_position)
		#						print "name: " + name
		#						print "sequence: " + self.m_current_mature_sequences[name].get_sequence()
		#						print "start: " + str(self.m_current_mature_sequences[name].get_start())
		#						print "end: " + str(self.m_current_mature_sequences[name].get_end())
			elif line_count > 4 and len(line.strip()) > 0: # This is the mature sequences
				mature_sequence = line.split()[0]
				entry = filename.split('/')[1][:len(filename.split('/')[1])-4]
				if entry in pairs:
					identifier = pairs[entry]
					if identifier in normalized:
#						print "in: " + str(identifier)
						count = normalized[identifier]
					else:
#						print "not in: " + str(identifier)
						count = 2
				else:
					count = 0
				
#				count = normalized[pairs[entry]]
#				print "count: " + str(count)
#				if entry in normalized:
#					count = normalized[pairs[entry]]# TODO
#				else:
#					count = 0
#				count = int(line.split()[1])
				# This is kind of a hack for the positions: there is 4 spaces before each lines that are not associated with the index
				start_position = line.index(mature_sequence) - 4
				end_position = start_position + len(mature_sequence)
#				print "mature_sequence: " + mature_sequence
#				print "start_position: " + str(start_position)
#				print "end_position: " + str(end_position)
				if self._check_and_update_wild_type(mature_sequence, count) == False:
					self.m_other_sequences.append(MatureSequence(mature_sequence, start_position, end_position))
					self.m_other_sequences[len(self.m_other_sequences)-1].set_count(count)
#					for other in self.m_other_sequences:
#						print "sequence: " + other.get_sequence()
#						print "start: " + str(other.get_start())
#						print "end: " + str(other.get_end())
			line_count += 1

	def _check_and_update_wild_type(self, sequence, count):
		for miRNA in self.m_current_mature_sequences:
			if self.m_current_mature_sequences[miRNA].get_sequence() == sequence:
				self.m_current_mature_sequences[miRNA].set_count(count)
				return True
		return False

	def _parse_results(self):
#		total_uridylation_count = 0
#		total_adenylation_count = 0
#		total_other_count = 0
#		total_none_count = 0
#		for i in range(0, len(self.m_other_sequences)):
#		print str(len(self.m_other_sequences))
		for miRNA in self.m_other_sequences:
			uridylation_count = 0
			adenylation_count = 0
			other_count = 0
			none_count = 0
			
			# 1. Find the strand
			strand = ""
			if miRNA.get_start() < (len(self.m_genomic_sequence)/2):
				strand = "5p"
			else:
				strand = "3p"

			if self.m_mode == "stats":
				toPrint = self.m_name
				printed = False
				for name in self.m_mature_allocator.get_mature_sequences(self.m_name):
					if printed == False and strand in name:
						toPrint += "\t" + name + "\t" + strand
						printed = True
				if printed == False:
					toPrint += "\t" + "-\t" + strand

				# 2. Discover why there was a mismatch
				sequence = miRNA.get_sequence()
				if self._check_none(sequence) == True:
					none_count += miRNA.get_count()
					
				elif self._check_uridylation(sequence) == True:
					uridylation_count += miRNA.get_count()
				elif self._check_adenylation(sequence) == True:
					adenylation_count += miRNA.get_count()
				else:
					other_count += miRNA.get_count()
				toPrint += "\t" + str(uridylation_count)
				toPrint += "\t" + str(adenylation_count)
				toPrint += "\t" + str(other_count)
				toPrint += "\t" + str(none_count)
				print toPrint

			elif self.m_mode == "count":
#				print "_____________"
#				print "name: " + self.m_name
#				print "seq: " + self.m_genomic_sequence + " (" + str(len(self.m_genomic_sequence)) + ")"
				# 3. Check at which position(s) the mismatch(es) is(are) found
				# 3.1 Check if the is a valid mature sequence associated with this side of the loop
				toCount = False
				reference = ""
				for name in self.m_mature_allocator.get_mature_sequences(self.m_name):
					if toCount == False and strand in name:
						if name in self.m_current_mature_sequences:
							reference = self.m_current_mature_sequences[name]
							toCount = True
				# 3.1.1 If there is one, calculate positions of mismatch
				if toCount == True:
					# 3.1.1.1 Check before reference sequence
#					print "ref_seq: " + reference.get_sequence()
#					print "other_seq: " + miRNA.get_sequence()
#					print "ref_start: " + str(reference.get_start())
#					print "other_start: " + str(miRNA.get_start())
					if miRNA.get_start() < reference.get_start():
						i = -1
						for j in range(0, reference.get_start() - miRNA.get_start()):
							countToPrint = i - j
							if countToPrint > -4:
								print str(countToPrint) + "\t" + str(miRNA.get_count())
					# 3.1.1.2 Check after reference sequence
#					print "ref_end: " + str(reference.get_end())
#					print "other_end: " + str(miRNA.get_end())
					if miRNA.get_end() > reference.get_end():
						i = reference.get_end()
						for j in range(0, miRNA.get_end() - reference.get_end()):
#							print "j: " + str(j)
							countToPrint = i + j - reference.get_start()
#							print countToPrint
							if j < 4:
								print str(countToPrint) + "\t" + str(miRNA.get_count())
					# 3.1.1.3 Check for other mismatches
					for i in range(reference.get_start(), miRNA.get_end()):
#						miRNA.get_sequence
						if i >= miRNA.get_start() and miRNA.get_sequence()[i-miRNA.get_start()] != self.m_genomic_sequence[i]:
#							print "-----"
#							print "i: " + str(i)
#							print miRNA.get_sequence()[i]
#							print self.m_genomic_sequence[i]
#							print self.m_name
							print str(i - reference.get_start()) + "\t" + str(miRNA.get_count())

	def _check_none(self, sequence):
		if sequence in self.m_genomic_sequence:
			return True
		return False

	def _check_uridylation(self, sequence):
		# 1. Remove U in 3p
		i = len(sequence) - 1
		while sequence[i] == 'U':
			i -= 1
		subsequence = sequence[:i]
		if subsequence in self.m_genomic_sequence:
			return True
		return False

	def _check_adenylation(self, sequence):
		# 1. Remove U in 3p
		i = len(sequence) - 1
		while sequence[i] == 'A':
			i -= 1
		subsequence = sequence[:i]
		if subsequence in self.m_genomic_sequence:
			return True
		return False

import sys

if __name__=="__main__":
	if len(sys.argv) == 1:
		print __doc__
                sys.exit(1)

        if len(sys.argv)!=7:
                print __doc__
                sys.exit(1)

	file_list = sys.argv[1]
	file_pairs = sys.argv[2]
	file_miRNA_sequences = sys.argv[3]
	mode = sys.argv[4]
	file_blast = sys.argv[5]
	file_collapsed = sys.argv[6]


sequence_counts = {}
#sequence_id = {}
collapsed_sequences = {}
count = 0
identifier = ""
for line in open(file_collapsed):
	if '>' in line:
		count = int(line.split()[3])
		identifier = line.split()[1][3:]
		sequence_counts[identifier] = count
	else:
		sequence = line.strip()
		collapsed_sequences[identifier] = sequence

normalized_counts = {}
mature_pair = {}
total_entry = {}
for line in open(file_blast):
	entry = line.split()[0]
	mature_name = line.split()[1]
	if entry not in total_entry:
		total_entry[entry] = 0
		mature_pair[mature_name] = entry
	total_entry[entry] += 1

for entry in sequence_counts:
	if entry in total_entry:
		normalized_counts[entry] = float(sequence_counts[entry]) / float(total_entry[entry])
#		print "in: " + entry + ": " + str(normalized_counts[entry])
	else:
		normalized_counts[entry] = float(sequence_counts[entry])
#		print "not in: " + entry + ": " + str(normalized_counts[entry])
#		normalized_counts[mature_pair[entry]] = float(sequence_counts[entry]) / float(total_entry[entry])

# 1. Load pairs
mature_allocator = MatureAllocator(file_pairs)

# TESTS:
#for entry in mature_allocator.m_pair_list:
#	print "------------"
#	print entry
#	print mature_allocator.get_mature_sequences(entry)
#	print mature_allocator.m_pair_list[entry]

# 2. Load mature sequences in a {}
mature_sequences = {}
for line in open(file_miRNA_sequences):
	if '>' in line:
		name = line.split()[0][1:]
	else:
		if '-' not in line: # Some lines only have the value "--", we want to skip them
			sequence = line.strip()
			mature_sequences[name] = sequence

# TESTS:
#for entry in mature_sequences:
#	print "----------"
#	print entry
#	print mature_sequences[entry]

# 3. Main loop:
# We iterate over each files:
for filename in open(file_list):
	sequence_analyzer = SequenceAnalyzer(filename.strip(), mature_sequences, mature_allocator, mode, normalized_counts, mature_pair)













